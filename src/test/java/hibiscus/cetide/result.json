{"code":0,"data":{"records":[{"id":"1834897546673995777","title":"关于antd的ProTable中数据值为valueEnum值时 数据回显问题","description":"今天在写面试鸭项目中，碰到了一个审核状态无法正确回显的问题","content":"## 问题展示\n代码：\n```\n          {\n            title: \"审核状态\",\n            dataIndex: \"reviewStatus\",\n            valueEnum: {\n              0: {\n                text: \"待审核\",\n                status: \"Default\",\n              },\n              1: {\n                text: \"通过\",\n                status: \"Success\",\n              },\n              2: {\n                text: \"拒绝\",\n                status: \"Error\",\n              },\n            },\n ```\n 代码点击修改后显示视图：\n \n<img src=\"https://pic.code-nav.cn/post_picture/1707418316274003969/jBDChNeKs7BNZccX.webp\" alt=\"image.png\" width=\"100%\" />\n\n实际数据：\n\n<img src=\"https://pic.code-nav.cn/post_picture/1707418316274003969/uXEXAXJv53uGNdA8.webp\" alt=\"image.png\" width=\"100%\" />\n\n我们在控制台中打印这个oldData发现：\n\n<img src=\"https://pic.code-nav.cn/post_picture/1707418316274003969/Y6yGHEjBKNJFjsv7.webp\" alt=\"image.png\" width=\"100%\" />\n\n这个reviewStatus是数字型啊，（可能我对前端了解不太深）我的理解是：\n```\n            valueEnum: {\n              0: {\n                text: \"待审核\",\n                status: \"Default\",\n              },\n              1: {\n                text: \"通过\",\n                status: \"Success\",\n              },\n              2: {\n                text: \"拒绝\",\n                status: \"Error\",\n              },\n            },\n```\n既然写的这个0是数字型，那么数据类型对应了为什么回显不对？\n然后一顿查：\n相关链接：https://github.com/ant-design/pro-components/issues/6969\n在2023年有人提出过这个问题，我们看看问题描述：\n\n\n<img src=\"https://pic.code-nav.cn/post_picture/1707418316274003969/CwiwDy0FKqV3AE3d.webp\" alt=\"image.png\" width=\"100%\" />\n和我们的问题一摸一样\n\n\n\n<img src=\"https://pic.code-nav.cn/post_picture/1707418316274003969/LtGzwx9b0vrQqfTB.webp\" alt=\"image.png\" width=\"100%\" />\n\n最后我们找到一段回复：\n\n<img src=\"https://pic.code-nav.cn/post_picture/1707418316274003969/3kjbraudXUkw6T9F.webp\" alt=\"image.png\" width=\"100%\" />\n\n也就是说这个reviewStatus 不能是数字型，这样的话直接改成字符串类型就好了！\n\n\n\n\n","plainTextDescription":"今天在写面试鸭项目中，碰到了一个审核状态无法正确回显的问题","category":"文章","cover":null,"thumbnailCover":null,"language":null,"externalLink":null,"shortLink":null,"componentName":null,"viewNum":3,"thumbNum":1,"favourNum":0,"commentNum":0,"priority":0,"userId":"1707418316274003969","planetPostId":null,"relatedId":null,"showPost":0,"reviewStatus":1,"reviewMessage":null,"reviewerId":null,"reviewTime":"2024-09-14 19:50:19","editTime":"2024-09-14 19:50:19","createTime":"2024-09-14 18:10:40","updateTime":"2024-09-14 19:50:19","accessScope":0,"user":{"id":"1707418316274003969","planetCode":"27777","planetPostAuth":1,"userName":"小张","userAvatar":"https://pic.code-nav.cn/user_avatar/1707418316274003969/WnOGd0ds-193127wXFyM.webp","userThumbnailAvatar":"https://pic.code-nav.cn/user_avatar/1707418316274003969/thumbnail/WnOGd0ds-193127wXFyM.webp","gender":1,"userProfile":null,"interests":[],"place":null,"school":"湖南文理学院","direction":"后端开发","graduationYear":2025,"company":null,"job":null,"github":null,"blog":null,"score":0,"jobStatus":null,"scoreLevel":1,"followeeNum":0,"followNum":0,"followStatus":null,"vipExpireTime":"2025-10-28 23:24:07","vipNumber":"27777","userRole":"vip","scoreRank":null,"postAllThumbNum":null,"postAllViewNum":null,"needGuide":0,"syncPopupLeftCount":0,"paymentInfo":null},"tags":["教程","笔记","Javascript","面试刷题项目"],"fileList":null,"videoList":[],"atUserList":null,"pictureList":null,"hasThumb":false,"hasFavour":false,"needVip":null,"atUserVOList":null,"status":null,"relatedLink":null,"acceptAnswerId":null},{"id":"1834890907443085313","title":"【鸿蒙实战开发】基于ArkUI现有能力实现自定义弹窗封装方案","description":"自定义弹窗是应用开发需要实现的基础功能，包括但不限于HarmonyOS开发者文档中定义的模态、半模态、Toast等形式，封装一个好用且和UI组件解耦的弹窗组件是开发者的高频诉求","content":"## **场景描述**\n\n自定义弹窗是应用开发需要实现的基础功能，包括但不限于HarmonyOS开发者文档中定义的模态、半模态、Toast等形式，封装一个好用且和UI组件解耦的弹窗组件是开发者的高频诉求\n\n自定义弹窗通常的使用场景有：\n\n### **场景一：在公共逻辑中触发弹窗**\n\n登录提示弹窗、全屏广告弹窗、网络请求与其他操作行为的提示、异常弹窗\n\n### **场景二：侧滑手势拦截**\n\n隐私弹窗的拦截，退出登录时的确认弹窗\n\n### **场景三：切换页面弹窗不消失**\n\n隐私弹窗和二级页面中的半模态弹窗\n\n### **场景四：自定义弹出、关闭动画**\n\n从下往上的抽屉式弹出、关闭时从上往下收回\n\n### **场景五：透明、模态、半模态背景**\n\n应用实现自定义的背景颜色\n\n## **方案描述**\n\n**1. 使用Navigation.Dialog**\n\n基于Navigation.Dialog的透明页面特性，可以用于实现弹窗效果\n\n而且Navigation.Dialog存在于路由栈中，天然可以实现切换页面弹窗不消失\n\n**当前限制：**\n\n弹窗组件中的动效建议开发者自行实现\n\nNavigation.Dialog自身无颜色，需要开发者自行实现模态遮罩，以及手势事件。\n\n**演示效果：**\n\n<img src=\"https://pic.code-nav.cn/post_picture/1834516631464710146/5mKY4x0r0rM8ITDJ.webp\" alt=\"\" width=\"320px\" />\n\n<img src=\"https://pic.code-nav.cn/post_picture/1834516631464710146/y6duoEFoUHx6qORW.webp\" alt=\"\" width=\"320px\" />\n\n<img src=\"https://pic.code-nav.cn/post_picture/1834516631464710146/EDvOzYeCEwBILTKG.webp\" alt=\"\" width=\"320px\" />\n\n<img src=\"https://pic.code-nav.cn/post_picture/1834516631464710146/FLyFNuPgSvUoFlmD.webp\" alt=\"\" width=\"320px\" />\n\n对于少量弹窗的实现，可以直接使用Navigation来进行路由跳转，参考 Navigation常见场景及解决方案 \n\n其他`Navigation`的使用也可参考上述文章\n\n## **步骤一：封装路由工具类，并注册自定义弹窗组件**\n\n定义路由工具类AppRouter，并创建路由栈NavPathStack\n\n```\nexport class AppRouter {\n\n  private static instance = new AppRouter();\n\n  private pathStack: NavPathStack = new NavPathStack();  // 初始化路由栈\n\n  public static getInstance(): AppRouter {\n\n    return AppRouter.instance;\n\n  }\n\n  public getPathStack(): NavPathStack {\n\n    return this.pathStack;\n\n  }\n\n  ...\n\n}\n```\n\n在根页面中注册NavPathStack\n\n```\n@Entry\n\n@Component\n\nstruct Index {\n\n  build() {\n\n    Navigation(AppRouter.getInstance().getPathStack()) {\n\n      ...\n\n    }\n\n  }\n\n}\n```\n\n在.navDestination注册封装的自定义弹窗组件DefaultDialog\n\n```\n@Builder\n\nPageMap(name: string) {\n\n  if (name === CommonConstants.DEFAULT_DIALOG) {\n\n    DefaultDialog()\n\n  }\n\n  ...\n\n}\n\nNavigation(AppRouter.getInstance().getPathStack()) {\n\n  ...\n\n}.navDestination(this.PageMap)\n```\n\n进阶用法：可以参考动态路由案例实现动态路由， HarmonyOS NEXT应用开发案例集 - Gitee.com \n\n### **步骤二：封装弹窗UI 组件**\n\n定义弹窗选项类AppDialogOption\n\n```\nexport class AppDialogOption {\n\n  view?: WrappedBuilder<Object[]> // 自定义弹窗内容组件\n\n  buildParams?: Object  // 自定义弹窗内容参数\n\n  params?: Object  // 打开时传递参数\n\n  autoClose?: number  // 自动关闭时间\n\n  onPop?: (data: PopInfo) => void  // 接收上一个弹窗关闭时的参数回调\n\n  onBackPressed?: () => boolean  // 侧滑返回拦截\n\n  styles?: AppDialogStyle = new AppDialogStyle()  // 弹窗样式\n\n  animation?: TransitionEffect  // 弹窗动画\n\n  instance?: AppDialog  // 弹窗操作对象\n\n}\n\n定义弹窗样式类AppDialogStyle\n\nexport class AppDialogStyle {\n\n  transparent: boolean = false\n\n  background: string = 'rgba(0,0,0,0.5)'\n\n  radius: Length = 5\n\n  align: Alignment = Alignment.Center\n\n}\n```\n\n创建自定义弹窗组件DefaultDialog\n\n通过Stack布局及2个Column容器实现模态遮罩和自定义弹窗内容，通过NavDestinationMode定义页面类型\n\n```\n@Component\n\nexport struct DefaultDialog {\n\n  private dialogOptions?: AppDialogOption;\n\n  build() {\n\n    NavDestination() {\n\n      Stack() {\n\n        Column() {\n\n          // 模态遮罩\n\n        }\n\n        Column() {\n\n          // 弹窗内容\n\n        }\n\n      }\n\n      .width(\"100%\")\n\n      .height(\"100%\")\n\n    }\n\n    .mode(NavDestinationMode.DIALOG)  // 页面类型为dialog\n\n  }\n\n}\n```\n\n通过.backgroundColor设置模态遮罩的背景颜色\n\n```\n...\n\nStack() {\n\n  Column() {\n\n    // 模态遮罩\n\n  }\n\n  .backgroundColor(this.dialogOptions?.styles?.transparent ? Color.Transparent : this.dialogOptions?.styles?.background) // 背景颜色\n\n  Column() {\n\n    // 弹窗内容\n\n  }\n\n}\n```\n\n通过Stack.alignContent设置弹窗定位\n\n```\nStack({\n\n  alignContent: this.dialogOptions?.styles?.align\n\n}) {\n\n  Column() {\n\n    // 模态遮罩\n\n  }\n\n  Column() {\n\n    // 弹窗内容\n\n  }\n\n}\n```\n\n### **步骤三：封装弹窗控制器，与UI 组件解耦**\n\n提供链式调用的Api\n\n```\nexport class AppDialog {\n\n  static indexArr: number[] = [];\n\n  private stackIndex: number = 0;\n\n  private options?: AppDialogOption;\n\n  public static buildWithOptions(options?: AppDialogOption): AppDialog {\n\n    let instance: AppDialog = new AppDialog();\n\n    // 获取并保存弹窗的路由栈序号\n\n    let index: number = AppRouter.getInstance().getPathStack().size() - 1;\n\n    AppDialog.indexArr.push(index);\n\n    instance.stackIndex = index;\n\n    instance.options = options;\n\n    options!.instance = instance;\n\n    return instance;\n\n  }\n\n  public static build(builder: WrappedBuilder<Object[]>): AppDialog {\n\n    let options: AppDialogOption = new AppDialogOption();\n\n    options.view = builder;\n\n    return AppDialog.buildWithOptions(options);\n\n  }\n\n  public static toast(msg: string): AppDialog {\n\n    let options: AppDialogOption = new AppDialogOption();\n\n    options.view = AppDialog.toastBuilder;\n\n    options.buildParams = msg;\n\n    return AppDialog.buildWithOptions(options);\n\n  }\n\n  public static closeAll(): void {\n\n    AppRouter.getInstance().getPathStack().removeByName(CommonConstants.DEFAULT_DIALOG);\n\n  }\n\n  public static closeLast(params?: Object): void {\n\n    let lastIndex = AppDialog.indexArr.pop()\n\n    if (!lastIndex) {\n\n      AppDialog.closeAll();\n\n    } else if (lastIndex && AppRouter.getInstance().getPathStack().size() > lastIndex) {\n\n      AppRouter.getInstance().getPathStack().popToIndex(lastIndex, params);\n\n    }\n\n  }\n\n  public open(): AppDialog {\n\n    AppRouter.getInstance()\n\n      .getPathStack()\n\n      .pushPathByName(CommonConstants.DEFAULT_DIALOG, this.options, this.options!.onPop!, true);\n\n    return this;\n\n  }\n\n  public close(params?: Object): void {\n\n    if (AppRouter.getInstance().getPathStack().size() > this.stackIndex) {\n\n      AppRouter.getInstance().getPathStack().popToIndex(this.stackIndex, params);\n\n    }\n\n  }\n\n  public buildParams(buildParams: Object): AppDialog {\n\n    this.options!.buildParams = buildParams;\n\n    return this;\n\n  }\n\n  public params(params: Object): AppDialog {\n\n    this.options!.params = params;\n\n    return this;\n\n  }\n\n  public onBackPressed(callback: () => boolean): AppDialog {...}\n\n  public onPop(callback: (data: PopInfo) => void): AppDialog {...}\n\n  public animation(animation: TransitionEffect): AppDialog {...}\n\n  public autoClose(time: number): AppDialog {...}\n\n  public align(align: Alignment): AppDialog {...}\n\n  public transparent(transparent: boolean): AppDialog {...}\n\n}\n```\n\n### **步骤四：页面与弹窗，弹窗与弹窗之间传递参数**\n\n通过路由跳转NavPathStack.pushPathByName传递参数\n\n在弹窗组件的.onReady事件中获取路由跳转参数。\n\n```\n@Component\n\nexport struct DefaultDialog {\n\n  private dialogOptions?: AppDialogOption;\n\n  build() {\n\n    NavDestination() {\n\n      ...\n\n    }\n\n    .onReady((ctx: NavDestinationContext) => {\n\n      console.log(\"onReady\")\n\n      this.dialogOptions = ctx.pathInfo.param as AppDialogOption;\n\n    })\n\n  }\n\n}\n```\n\n使用NavPathStack中的onPop回调来接收上一个弹窗返回的参数。\n\n```\nonPop = (data: PopInfo) => {\n\n  console.log(\"onPop\")\n\n  // 更新状态变量\n\n  this.params[index] = JSON.stringify(data.result)\n\n}\n\nnavPathStack.pushPathByName(CommonConstants.DEFAULT_DIALOG, this.options, this.options!.onPop!, true)\n```\n\n上一个弹窗在关闭时传入参数\n\n```\nnavPathStack.popToIndex(this.stackIndex, params);\n```\n\n### **步骤五：实现弹窗自定义动画**\n\n通过.transition属性分别实现背景和内容的转场动画\n\n```\n...\n\nStack() {\n\n  Column() {\n\n    // 模态遮罩\n\n  }\n\n  .transition(  // 转场动画\n\n    TransitionEffect.OPACITY.animation({\n\n      duration: 300,\n\n      curve: Curve.Friction\n\n    })\n\n  )\n\n  Column() {\n\n    // 弹窗内容\n\n  }\n\n  .transition(  // 转场动画\n\n    this.dialogOptions?.animation ?\n\n      this.dialogOptions?.animation :\n\n    TransitionEffect.scale({ x: 0, y: 0 }).animation({\n\n      duration: 300,\n\n      curve: Curve.Friction\n\n    })\n\n  )\n\n}\n```\n\n通过监听模态遮罩的点击事件实现关闭动画\n\n```\n...\n\nStack() {\n\n  Column() {\n\n    // 模态遮罩\n\n  }\n\n  .opacity(this.opacityNum)\n\n  .onClick(() => {\n\n    animateTo({\n\n      duration: 200,\n\n      curve: Curve.Friction,\n\n      onFinish: () => {\n\n        this.dialogOptions?.instance?.close();\n\n      }\n\n    }, () => {\n\n      this.opacityNum = 0  // 修改模态遮罩的透明度\n\n      if (this.dialogOptions?.styles?.align === Alignment.Bottom) {\n\n        this.translateY = \"100%\"\n\n      }\n\n    })\n\n  })\n\n  Column() {\n\n    // 弹窗内容\n\n  }\n\n  .translate({ x: 0, y: this.translateY })\n\n}\n```\n\n### **步骤五：实现自定义弹窗内容**\n\n在弹窗内容的Column容器中传入WrappedBuilder来实现动态的自定义弹窗内容。\n\n```\nStack() {\n\n  Column() {\n\n    // 模态遮罩\n\n  }\n\n  Column() {\n\n    // 弹窗内容\n\n    this.dialogOptions?.view?.builder(this.dialogOptions);\n\n  }\n\n}\n```\n\n定义弹窗内容组件\n\n```\n@Builder\n\nexport function DialogViewBuilder(dialogOptions: AppDialogOption) {\n\n  DialogView({ options: dialogOptions })\n\n}\n\n@Component\n\nstruct DialogView {\n\n  private options?: dialogOptions ;\n\n  build() {\n\n    Column() {\n\n    }\n\n    ...\n\n  }\n\n}\n```\n\n### **步骤六：侧滑手势拦截**\n\n在弹窗组件的.onBackPressed事件中进行拦截\n\n```\n@Component\n\nexport struct DefaultDialog {\n\n  private dialogOptions?: AppDialogOption;\n\n  build() {\n\n    NavDestination() {\n\n      ...\n\n    }\n\n    .onBackPressed((): boolean => {\n\n      // true为拦截\n\n      if (this.dialogOptions?.onBackPressed) {\n\n        return this.dialogOptions?.onBackPressed()\n\n      } else {\n\n        return false;\n\n      }\n\n    })\n\n  }\n\n}\n```\n\n**使用效果：**\n\n使用弹窗控制器即可在非UI业务逻辑中打开弹窗\n\n```\nexport class AppService {\n\n  buzz(): void {\n\n    setTimeout(() => {\n\n      AppDialog\n\n        .toast(\"登录成功\")\n\n        .onBackPressed(() => true)\n\n        .autoClose(2000)\n\n        .transparent(true)\n\n        .open();\n\n    }, 1000)  // 模拟业务接口调用耗时\n\n  }\n\n}\n\nAppDialog.toastBuilder = wrapBuilder(ToastViewBuilder)\n\n@Builder\n\nexport function ToastViewBuilder(dialogOptions: AppDialogOption) {\n\n  ToastView({ msg: dialogOptions.buildParams as string })\n\n}\n\n@Component\n\nstruct ToastView {\n\n  private msg?: string;\n\n  build() {\n\n    Column() {\n\n      Text(this.msg)\n\n        .fontSize(14)\n\n        .fontColor(Color.White)\n\n        .padding(10)\n\n    }\n\n    .backgroundColor(\"rgba(0,0,0,0.8)\")\n\n    .justifyContent(FlexAlign.Center)\n\n    .borderRadius(12)\n\n    .width(100)\n\n  }\n\n}\n```\n\n关闭弹窗\n\n```\n// 全局使用\n\nAppDialog.closeLast();\n\nAppDialog.closeAll();\n\n// 弹窗页面中使用\n\nthis.dialogOptions?.instance?.close();\n```\n\n## 写在最后\n**如果你觉得这篇内容对你还蛮有帮助，我想邀请你帮我三个小忙：**\n\n* 点赞，转发，有你们的 『点赞和评论』，才是我创造的动力；\n* 关注小编，同时可以期待后续文章ing\uD83D\uDE80，不定期分享原创知识；\n* **想要获取更多完整鸿蒙最新学习知识点，可关注B站：码牛课堂鸿蒙开发；**","plainTextDescription":"自定义弹窗是应用开发需要实现的基础功能，包括但不限于HarmonyOS开发者文档中定义的模态、半模态、Toast等形式，封装一个好用且和UI组件解耦的弹窗组件是开发者的高频诉求","category":"文章","cover":"https://pic.code-nav.cn/post_cover/1834516631464710146/pqWtRLdOmbhGNdlc.jpg","thumbnailCover":"https://pic.code-nav.cn/post_cover/1834516631464710146/thumbnail/pqWtRLdOmbhGNdlc.jpg","language":null,"externalLink":null,"shortLink":null,"componentName":null,"viewNum":3,"thumbNum":3,"favourNum":0,"commentNum":0,"priority":0,"userId":"1834516631464710146","planetPostId":null,"relatedId":null,"showPost":0,"reviewStatus":1,"reviewMessage":"通过审核","reviewerId":null,"reviewTime":"2024-09-14 17:44:18","editTime":"2024-09-14 17:44:17","createTime":"2024-09-14 17:44:17","updateTime":"2024-09-14 19:50:31","accessScope":0,"user":{"id":"1834516631464710146","planetCode":null,"planetPostAuth":0,"userName":"OH小贾","userAvatar":"https://pic.code-nav.cn/user_avatar/1834516631464710146/Uz7VVwiDIcrZzHUp.jpg","userThumbnailAvatar":"https://pic.code-nav.cn/user_avatar/1834516631464710146/thumbnail/Uz7VVwiDIcrZzHUp.jpg","gender":1,"userProfile":null,"interests":[],"place":null,"school":null,"direction":null,"graduationYear":null,"company":null,"job":null,"github":null,"blog":null,"score":0,"jobStatus":null,"scoreLevel":1,"followeeNum":3,"followNum":0,"followStatus":null,"vipExpireTime":null,"vipNumber":null,"userRole":"user","scoreRank":null,"postAllThumbNum":null,"postAllViewNum":null,"needGuide":0,"syncPopupLeftCount":0,"paymentInfo":null},"tags":["移动开发","鸿蒙","UI","软件开发"],"fileList":null,"videoList":[],"atUserList":null,"pictureList":null,"hasThumb":false,"hasFavour":false,"needVip":null,"atUserVOList":null,"status":null,"relatedLink":null,"acceptAnswerId":null},{"id":"1834874265107513345","title":"【鸿蒙实战开发】基于Taskpool的多线程操作","description":"场景一：周期性任务处理，业务通过taskpool周期性处理业务。\n\n场景二：延迟业务处理，业务一段时间后，通过taskpool处理业务。\n\n场景三：串行业务处理，业务开展过程中，需要处理一系列的事务，事务处理过程中，存在先后次序。\n\n场景四：业务的处理存在紧急优先次序，支持设置taskpool优先级处理。\n\n场景五：ArkTS与Native协作开展业务，在ArkTS层触发业务，通过NAPI接口，传","content":"## **场景描述**\n\n**场景一**：周期性任务处理，业务通过taskpool周期性处理业务。\n\n**场景二**：延迟业务处理，业务一段时间后，通过taskpool处理业务。\n\n**场景三**：串行业务处理，业务开展过程中，需要处理一系列的事务，事务处理过程中，存在先后次序。\n\n**场景四**：业务的处理存在紧急优先次序，支持设置taskpool优先级处理。\n\n**场景五**：ArkTS与Native协作开展业务，在ArkTS层触发业务，通过NAPI接口，传递到Native C++层，作业务管理等处理。\n\n## **方案描述**\n\n### **场景一：周期性任务**\n\n方案：\n\n1)定时器判断周期性事务执行。\n\n2)Taskpool来处理任务执行。\n\n<img src=\"https://pic.code-nav.cn/post_picture/1834516631464710146/Oy7PWV7vDzLNJfyH.webp\" alt=\"\" width=\"100%\" />\n\n核心代码：\n\n```\n@Concurrent\n\nfunction ServiceHandle(pars: number): number {\n\n  hilog.info(0x0000, 'testTag', 'start ServiceHandle:%{public}d', pars);\n\n  // 业务处理过程,并将结果返回\n\n  let result = 0;\n\n  return result;\n\n}\n\nlet count = 0;\n\nfunction TimerOutHandle(pars:number)\n\n{\n\n  count++;\n\n  let task: taskpool.Task = new taskpool.Task(ServiceHandle, pars);\n\n  hilog.info(0x0000, 'testTag', 'Timer handle count :%{public}d,pars %{public}d', count, pars);\n\n  taskpool.execute(task, taskpool.Priority.HIGH).then((res: object) => {\n\n    hilog.info(0x0000, 'testTag', 'ServiceHandle result :%{public}d', res);\n\n    if (g_callback != null) {\n\n      g_callback(count);\n\n    }\n\n  });\n\n}\n\nlet timerId = -1;\n\nexport function TimerTest()\n\n{\n\n  count = 0;\n\n  let value = 88;\n\n  timerId = setInterval(TimerOutHandle, 3000, value);\n\n}\n```\n\n定时器每3秒超时一次，进入TimerOutHandle函数处理，TimerOutHandle函数体中，通过taskpool创建异步并发任务执行业务。\n\n**运行结果：**\n\n<img src=\"https://pic.code-nav.cn/post_picture/1834516631464710146/oWYY1Lceok77VNxd.webp\" alt=\"\" width=\"100%\" />\n\n界面上，每超时一次，会呈现运行次数：\n\n<img src=\"https://pic.code-nav.cn/post_picture/1834516631464710146/koRLKLR306s6e9cy.webp\" alt=\"\" width=\"417px\" />\n\n### **场景二：延迟任务**\n\n方案：\n\n1)通过setTimeout来延迟处理。\n\n2) 通过executeDelayed来延迟处理。\n\n核心代码：\n\n1）setTimeout的处理如下：\n\n```\n@Concurrent\n\nfunction ServiceHandle(pars: number): number {\n\n  hilog.info(0x0000, 'testTag', 'start ServiceHandle:%{public}d', pars);\n\n  // 业务处理过程,并将结果返回\n\n  let result = 0;\n\n  return result;\n\n}\n\nlet count = 0;\n\nfunction TimerOutHandle(pars:number)\n\n{\n\n  count++;\n\n  let task: taskpool.Task = new taskpool.Task(ServiceHandle, pars);\n\n  hilog.info(0x0000, 'testTag', 'Timer handle count :%{public}d,pars %{public}d', count, pars);\n\n  taskpool.execute(task, taskpool.Priority.HIGH).then((res: object) => {\n\n    hilog.info(0x0000, 'testTag', 'ServiceHandle result :%{public}d', res);\n\n    if (g_callback != null) {\n\n      g_callback(count);\n\n    }\n\n  });\n\n}\n\nexport function OneTimerCallTest()\n\n{\n\n  count = 0;\n\n  if (g_callback != null) {\n\n    g_callback(count);\n\n  }\n\n  let value = 99;\n\n  hilog.info(0x0000, 'testTag', 'start setTimeout');\n\n  timerId = setTimeout(TimerOutHandle, 3000, value);\n\n}\n```\n\n定时器3秒超时（仅仅执行一次）后，就会进入TimerOutHandle函数处理，TimerOutHandle函数体中，通过taskpool创建异步并发任务执行业务。\n\n2）executeDelayed来延迟\n\n```\n@Concurrent\n\nfunction TaskDelayServiceHandle(pars: number): number {\n\n  let t: number = Date.now();\n\n  hilog.info(0x0000, 'testTag', 'enter TaskDelayServiceHandle, timer is :%{public}d', t);\n\n  // 业务处理过程,并将结果返回\n\n  let result = 0;\n\n  return result;\n\n}\n\nexport function TaskPoolDelayTest()\n\n{\n\n  count = 0;\n\n  if (g_callback != null) {\n\n    g_callback(count);\n\n  }\n\n  let value = 100;\n\n  let t: number = Date.now();\n\n  hilog.info(0x0000, 'testTag', 'taskpool start time is :%{public}d', t);\n\n  let task: taskpool.Task = new taskpool.Task(TaskDelayServiceHandle, value);\n\n  taskpool.executeDelayed(3000, task).then(() => {\n\n    count++;\n\n    let t: number = Date.now();\n\n    hilog.info(0x0000, 'testTag', 'taskpool execute success, time is :%{public}d', t);\n\n    if (g_callback != null) {\n\n      g_callback(count);\n\n    }\n\n  }).catch((e: BusinessError) => {\n\n    console.error(`taskpool execute: Code: ${e.code}, message: ${e.message}`);\n\n  })\n\n}\n```\n\n调用executeDelayed函数3秒后，会进入TaskDelayServiceHandle函数执行，返回返回后，会进入executeDelayed后面的then的函数体中执行。\n\n**运行结果：**\n\n1）使用setTimeout运行结果\n\n<img src=\"https://pic.code-nav.cn/post_picture/1834516631464710146/Fc84EA4Dl4BwLvdc.webp\" alt=\"\" width=\"100%\" />\n\n2）使用executeDelayed运行结果\n\n<img src=\"https://pic.code-nav.cn/post_picture/1834516631464710146/RezpwzM8Zh2GkzFZ.webp\" alt=\"\" width=\"100%\" />\n\n### **场景三：串行任务**\n\n方案：\n\n1）最简单的方案就是后面任务执行时，根据前面任务的执行结果来处理。\n\n<img src=\"https://pic.code-nav.cn/post_picture/1834516631464710146/4qW5I7ZwqqEUKlNa.webp\" alt=\"\" width=\"286px\" />\n\n2）后面任务的执行，依赖另一个任务的一些处理结果后，继续执行。\n\n<img src=\"https://pic.code-nav.cn/post_picture/1834516631464710146/MJyjjvOH2JYhD6It.webp\" alt=\"\" width=\"459px\" />\n\n核心代码：\n\n1）通过业务逻辑的结果来处理\n\n```\n@Concurrent\n\nfunction ServiceHandle1(pars: number): number {\n\n  hilog.info(0x0000, 'testTag', 'start ServiceHandle1:%{public}d', pars);\n\n  // 业务处理过程,并将结果返回\n\n  let result = 0;\n\n  return result;\n\n}\n\n@Concurrent\n\nfunction ServiceHandle2(pars: number): number {\n\n  hilog.info(0x0000, 'testTag', 'start ServiceHandle2:%{public}d', pars);\n\n  // 业务处理过程,并将结果返回\n\n  let result = 1;\n\n  return result;\n\n}\n\nexport function SyncHandle()\n\n{\n\n  let task1: taskpool.Task = new taskpool.Task(ServiceHandle1, 1);\n\n  hilog.info(0x0000, 'testTag', 'sync handle');\n\n  taskpool.execute(task1, taskpool.Priority.HIGH).then((res1: object) => {\n\n    hilog.info(0x0000, 'testTag', 'ServiceHandle result :%{public}d', res1);\n\n    if (g_callback != null) {\n\n      g_callback('task1 finish.');\n\n    }\n\n    if ((res1 as Number) == 0) {\n\n      let task2: taskpool.Task = new taskpool.Task(ServiceHandle2, 2);\n\n      taskpool.execute(task2, taskpool.Priority.HIGH).then((res2: object) => {\n\n        hilog.info(0x0000, 'testTag', 'ServiceHandle2 result :%{public}d', res2);\n\n        if (g_callback != null) {\n\n          g_callback('task2 finish.');\n\n        }\n\n      });\n\n    }\n\n  });\n\n}\n```\n\ntask1执行完毕后，根据if判断启动task2任务执行。\n\n2）通过addDependency或SequenceRunner处理。\n\n```\n@Concurrent\n\nfunction DependencyHandle(args: number): number {\n\n  let t: number = Date.now();\n\n  while ((Date.now() - t) < 1000) {\n\n    continue;\n\n  }\n\n  return args;\n\n}\n\nexport function AddDependencyTest()\n\n{\n\n  let task1:taskpool.Task = new taskpool.Task(DependencyHandle, 100);\n\n  let task2:taskpool.Task = new taskpool.Task(DependencyHandle, 200);\n\n  let task3:taskpool.Task = new taskpool.Task(DependencyHandle, 300);\n\n  hilog.info(0x0000, 'testTag', 'dependency: add dependency start');\n\n  task1.addDependency(task2);\n\n  task2.addDependency(task3);\n\n  hilog.info(0x0000, 'testTag', 'dependency: add dependency end');\n\n  hilog.info(0x0000, 'testTag', 'dependency: start execute second');\n\n  taskpool.execute(task1).then(() => {\n\n    hilog.info(0x0000, 'testTag', 'dependency: first task1 success');\n\n    if (g_callback != null) {\n\n      g_callback('task1 finish.');\n\n    }\n\n  })\n\n  taskpool.execute(task2).then(() => {\n\n    hilog.info(0x0000, 'testTag', 'dependency: second task2 success');\n\n    if (g_callback != null) {\n\n      g_callback('task2 finish.');\n\n    }\n\n  })\n\n  taskpool.execute(task3).then(() => {\n\n    hilog.info(0x0000, 'testTag', 'dependency: third task3 success');\n\n    if (g_callback != null) {\n\n      g_callback('task3 finish.');\n\n    }\n\n  })\n\n}\n```\n\ntask1依赖task2，task2依赖task3，上面任务执行的顺序是：task3执行完毕后再执行task2，最后执行task。\n\n```\n@Concurrent\n\nfunction additionDelay(delay:number): void {\n\n  let start: number = new Date().getTime();\n\n  while (new Date().getTime() - start < delay) {\n\n    continue;\n\n  }\n\n}\n\n@Concurrent\n\nfunction waitForRunner(finalString: string): string {\n\n  return finalString;\n\n}\n\nexport async function SeqRunnerTest()\n\n{\n\n  let finalString:string = \"\";\n\n  let task1:taskpool.Task = new taskpool.Task(additionDelay, 3000);\n\n  let task2:taskpool.Task = new taskpool.Task(additionDelay, 2000);\n\n  let task3:taskpool.Task = new taskpool.Task(additionDelay, 1000);\n\n  let task4:taskpool.Task = new taskpool.Task(waitForRunner, finalString);\n\n  let runner:taskpool.SequenceRunner = new taskpool.SequenceRunner();\n\n  runner.execute(task1).then(() => {\n\n    finalString += 'task1 finish.';\n\n    hilog.info(0x0000, 'testTag', 'seqrunner: task1 done.');\n\n    if (g_callback != null) {\n\n      g_callback('task1 finish.');\n\n    }\n\n  });\n\n  runner.execute(task2).then(() => {\n\n    finalString += 'task2 finish.';\n\n    hilog.info(0x0000, 'testTag', 'seqrunner: task2 done.');\n\n    if (g_callback != null) {\n\n      g_callback('task2 finish.');\n\n    }\n\n  });\n\n  runner.execute(task3).then(() => {\n\n    finalString += 'task3 finish.';\n\n    hilog.info(0x0000, 'testTag', 'seqrunner: task3 done.');\n\n    if (g_callback != null) {\n\n      g_callback('task3 finish.');\n\n    }\n\n  });\n\n  await runner.execute(task4);\n\n  hilog.info(0x0000, 'testTag', 'seqrunner: task4 done, finalString is %{public}s', finalString);\n\n}\n```\n\ntask1执行完毕后，执行task2，最后是task3执行完毕。\n\n运行结果：\n\n1）通过业务逻辑的结果来处理\n\n<img src=\"https://pic.code-nav.cn/post_picture/1834516631464710146/ag2Xtr1MArKC8o7p.webp\" alt=\"\" width=\"100%\" />\n\n2）通过addDependency或SequenceRunner处理\n\n<img src=\"https://pic.code-nav.cn/post_picture/1834516631464710146/xSei3GWXbe23FxuU.webp\" alt=\"\" width=\"100%\" />\n\n## **场景四：优先级任务**\n\n方案：\n\n在taskpool.execute的参数二种设置线程的优先级，优先级分三个级别：LOW、MEDIUM（默认）、HIGH。通过设置优先级来运行taskpool任务。\n\n核心代码：\n\n```\n@Concurrent\n\nfunction ServiceHandle(pri: string): string {\n\n  hilog.info(0x0000, 'testTag', 'enter ServiceHandle:%{public}s', pri);\n\n  hilog.info(0x0000, 'testTag', 'end ServiceHandle:%{public}s', pri);\n\n  return pri;\n\n}\n\nexport function CallPriorityHanel()\n\n{\n\n  let task1: taskpool.Task = new taskpool.Task(ServiceHandle, \"LOW\");\n\n  let task2: taskpool.Task = new taskpool.Task(ServiceHandle, \"MEDIUM\");\n\n  let task3: taskpool.Task = new taskpool.Task(ServiceHandle, \"HIGH\");\n\n  taskpool.execute(task1, taskpool.Priority.LOW).then((res: object) => {\n\n    hilog.info(0x0000, 'testTag', 'task return result :%{public}s', res);\n\n  });\n\n  taskpool.execute(task2, taskpool.Priority.MEDIUM).then((res: object) => {\n\n    hilog.info(0x0000, 'testTag', 'task return result :%{public}s', res);\n\n  });\n\n  taskpool.execute(task3, taskpool.Priority.HIGH).then((res: object) => {\n\n    hilog.info(0x0000, 'testTag', 'task return result :%{public}s', res);\n\n  });\n\n}\n```\n\n当前的设备都是多核的，并不是说将优先级设置程HIGH,该任务就会最先调度。\n\n**运行结果：**\n\n<img src=\"https://pic.code-nav.cn/post_picture/1834516631464710146/vdhpoXsJVLhBw5VZ.webp\" alt=\"\" width=\"100%\" />\n\n**场景五：taskpool****的Napi****调用**\n\n方案：C++层编译的库，在ArkTS层通过import库的方式引用后，在taskpool的回调函数中调用接口。核心代码：\n\n```\n@Concurrent\n\nfunction ServiceHandle(pars: number): number {\n\n  hilog.info(0x0000, 'testTag', 'start ServiceHandle:%{public}d', pars);\n\n  // 业务处理过程,并将结果返回\n\n  testNapi.jsServiceHandle(88, 99);\n\n  return 0;\n\n}\n\nexport function CallHandle()\n\n{\n\n  let task: taskpool.Task = new taskpool.Task(ServiceHandle, 1);\n\n  taskpool.execute(task,).then((res: object) => {\n\n    hilog.info(0x0000, 'testTag', 'printArgs result :%{public}d', res);\n\n  });\n\n}\n\ntypedef struct TestData {\n\n  int data;\n\n  int type;\n\n} TestData;\n\nstatic napi_value JsServiceHandle(napi_env env, napi_callback_info info)\n\n{\n\n  size_t argc = 2;\n\n  napi_value args[2] = {nullptr};\n\n  napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);\n\n  TestData testData;\n\n  napi_get_value_int32(env, args[0], &testData.data);\n\n  napi_get_value_int32(env, args[1], &testData.type);\n\n  OH_LOG_INFO(LOG_APP, \"Native C++ Service handle：%{public}d,type：%{public}d\", testData.data, testData.type);\n\n  return nullptr;\n\n}\n\nEXTERN_C_START\n\nstatic napi_value Init(napi_env env, napi_value exports)\n\n{\n\n  napi_property_descriptor desc[] = {\n\n  {\"jsServiceHandle\", nullptr, JsServiceHandle, nullptr, nullptr, nullptr, napi_default, nullptr}\n\n};\n\nnapi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);\n\nreturn exports;\n\n}\n\nEXTERN_C_END\n```\n\n**运行结果：**\n\n<img src=\"https://pic.code-nav.cn/post_picture/1834516631464710146/QwLDkk5Y0LbuFqTw.webp\" alt=\"\" width=\"100%\" />\n","plainTextDescription":"场景一：周期性任务处理，业务通过taskpool周期性处理业务。\n\n场景二：延迟业务处理，业务一段时间后，通过taskpool处理业务。\n\n场景三：串行业务处理，业务开展过程中，需要处理一系列的事务，事务处理过程中，存在先后次序。\n\n场景四：业务的处理存在紧急优先次序，支持设置taskpool优先级处理。\n\n场景五：ArkTS与Native协作开展业务，在ArkTS层触发业务，通过NAPI接口，传","category":"文章","cover":"https://pic.code-nav.cn/post_cover/1834516631464710146/eMOEUdyn8iYDwTfM.webp","thumbnailCover":"https://pic.code-nav.cn/post_cover/1834516631464710146/thumbnail/eMOEUdyn8iYDwTfM.jpg","language":null,"externalLink":null,"shortLink":null,"componentName":null,"viewNum":5,"thumbNum":2,"favourNum":0,"commentNum":0,"priority":0,"userId":"1834516631464710146","planetPostId":null,"relatedId":null,"showPost":0,"reviewStatus":1,"reviewMessage":"通过审核","reviewerId":null,"reviewTime":"2024-09-14 16:38:10","editTime":"2024-09-14 16:38:09","createTime":"2024-09-14 16:38:09","updateTime":"2024-09-14 19:51:40","accessScope":0,"user":{"id":"1834516631464710146","planetCode":null,"planetPostAuth":0,"userName":"OH小贾","userAvatar":"https://pic.code-nav.cn/user_avatar/1834516631464710146/Uz7VVwiDIcrZzHUp.jpg","userThumbnailAvatar":"https://pic.code-nav.cn/user_avatar/1834516631464710146/thumbnail/Uz7VVwiDIcrZzHUp.jpg","gender":1,"userProfile":null,"interests":[],"place":null,"school":null,"direction":null,"graduationYear":null,"company":null,"job":null,"github":null,"blog":null,"score":0,"jobStatus":null,"scoreLevel":1,"followeeNum":3,"followNum":0,"followStatus":null,"vipExpireTime":null,"vipNumber":null,"userRole":"user","scoreRank":null,"postAllThumbNum":null,"postAllViewNum":null,"needGuide":0,"syncPopupLeftCount":0,"paymentInfo":null},"tags":["鸿蒙","移动开发","软件开发","多线程"],"fileList":null,"videoList":[],"atUserList":null,"pictureList":null,"hasThumb":false,"hasFavour":false,"needVip":null,"atUserVOList":null,"status":null,"relatedLink":null,"acceptAnswerId":null},{"id":"1834856495951200258","title":"9.13杭州某小厂面经 ","description":"第二场面试 问了api项目  伙伴匹配项目","content":"# 杭州某小厂  面试时间 晚上8点 (第二场)\n## 自我介绍\n自我介绍\n当时和女朋友在校园里逛着呢，突然面试官打来电话了....慌的一批在操场上面试的....\n## 拷打项目\n### api开放平台项目\n1. 介绍一下api项目和伙伴匹配项目\n1. 如何开发的客户端sdk？解释了一通，感觉这个面试官似懂非懂.....\n2. API签名认证算法是怎么做的？\n3. 如何进行鉴权的？\n4. 管理员是怎么可视化各接口的调用情况的？\n\n感觉面试官不太理解这个项目，问的很少.....\n### 伙伴匹配项目\n1. 使用redis缓存后响应时长是怎么测试的？\n2. 为什么降低了这么多？\n3. 如何使用redis实现redis缓存的？\n4. 缓存预热是怎么实现的？\n5. 解释一下什么是线程安全？\n6. redis如何实现分布式锁的？\n\n### 八股文\n1. Java的基本数据类型？\n2. 什么是AOP？AOP可以做什么？\n3. SpringBoot和SpringMVC的区别？\n4. 了解SpringMVC的工作流程吗？\n5. 如何实现动态代理？\n6. 了解过哪些数据库？\n7. 一些场景写sql，其中有左连接和右连接，右连接场景没回答对，也确实好长时间没联表查询过了，不过我答出来了是右连接\n8. vue传值有几种方式？\n\n### 总结\n昨天晚上面试的时候，也没有准备，回答的感觉没有上午那场好，回答完问了一下面试官感觉怎么样，他说还不错，我当时感觉可能g了，就没抱啥希望，没想到今天上午给发offer了。\n","plainTextDescription":"第二场面试 问了api项目  伙伴匹配项目","category":"文章","cover":null,"thumbnailCover":null,"language":null,"externalLink":null,"shortLink":null,"componentName":null,"viewNum":39,"thumbNum":3,"favourNum":1,"commentNum":2,"priority":0,"userId":"1698638875859197953","planetPostId":null,"relatedId":null,"showPost":0,"reviewStatus":1,"reviewMessage":null,"reviewerId":null,"reviewTime":"2024-09-14 19:53:16","editTime":"2024-09-14 19:53:16","createTime":"2024-09-14 15:27:33","updateTime":"2024-09-14 20:12:00","accessScope":0,"user":{"id":"1698638875859197953","planetCode":"33488","planetPostAuth":1,"userName":"不是真的冷漠","userAvatar":"https://pic.code-nav.cn/user_avatar/1698638875859197953/Tf9UinPQ-Image_1709394789376.jpg","userThumbnailAvatar":"https://pic.code-nav.cn/user_avatar/1698638875859197953/thumbnail/Tf9UinPQ-Image_1709394789376.jpg","gender":1,"userProfile":null,"interests":[],"place":null,"school":"河南师范大学","direction":"Java后端","graduationYear":2026,"company":null,"job":null,"github":null,"blog":null,"score":0,"jobStatus":null,"scoreLevel":1,"followeeNum":1,"followNum":0,"followStatus":null,"vipExpireTime":"2025-04-01 23:41:46","vipNumber":"33488","userRole":"vip","scoreRank":null,"postAllThumbNum":null,"postAllViewNum":null,"needGuide":0,"syncPopupLeftCount":1,"paymentInfo":null},"tags":["面经","API开放平台","伙伴匹配项目"],"fileList":null,"videoList":[],"atUserList":null,"pictureList":null,"hasThumb":false,"hasFavour":false,"needVip":null,"atUserVOList":null,"status":null,"relatedLink":null,"acceptAnswerId":null},{"id":"1834852245120565249","title":"9.13杭州某小厂面经 ","description":"第一场面试项目只问了伙伴匹配系统","content":"# 第一场面试 早上10点 杭州某小厂\n## 自我介绍\n1. 自我介绍在自我介绍的过程中，对大模型这一块有没有了解，因为这家公司是做大模型相关的，我说我只用过，看过相关文章。\n## 拷打项目\n1. 看到我伙伴匹配项目上写到通过使用redis缓存减小接口响应的时长，怎么接口响应时长，是怎么做的？\n2. 如何优化数据库逻辑以减少数据库查询的时间？ 面试官建议我学一下elasticSearch\n3. 如何解决redis中的数据和数据库中的数据不一致？\n4. 讲一下什么是线程安全？线程池参数有哪些？\n5. 如何解决多线程环境下线程安全问题？\n6. 学习过消息队列吗？ 什么时候能用到消息队列？\n## 八股文\n1. HashMap的底层数据结构？\n2. 哈希表在搜索的时间复杂度是多少？\n3. 什么是Hash碰撞？HashMap底层如何解决hash冲突的？\n4. 链表在搜索的时间复杂度是多少？\n6. 链表是什么样的？\n7. 如果要插入一个数据链表的时间复杂度是多少？\n8. 链表的优势和劣势？\n9. 设计模式了解过吗？了解过，装饰者模式  什么时候用到装饰者模式？\n10. 一些场景写sql语句\n\n## 未来发展方向\n1. 有没有想往ai大模型发展的想法？\n2. 后续需要接着学习什么？","plainTextDescription":"第一场面试项目只问了伙伴匹配系统","category":"文章","cover":null,"thumbnailCover":null,"language":null,"externalLink":null,"shortLink":null,"componentName":null,"viewNum":30,"thumbNum":1,"favourNum":0,"commentNum":0,"priority":0,"userId":"1698638875859197953","planetPostId":null,"relatedId":null,"showPost":0,"reviewStatus":1,"reviewMessage":null,"reviewerId":null,"reviewTime":"2024-09-14 19:54:33","editTime":"2024-09-14 19:54:33","createTime":"2024-09-14 15:10:39","updateTime":"2024-09-14 20:15:22","accessScope":0,"user":{"id":"1698638875859197953","planetCode":"33488","planetPostAuth":1,"userName":"不是真的冷漠","userAvatar":"https://pic.code-nav.cn/user_avatar/1698638875859197953/Tf9UinPQ-Image_1709394789376.jpg","userThumbnailAvatar":"https://pic.code-nav.cn/user_avatar/1698638875859197953/thumbnail/Tf9UinPQ-Image_1709394789376.jpg","gender":1,"userProfile":null,"interests":[],"place":null,"school":"河南师范大学","direction":"Java后端","graduationYear":2026,"company":null,"job":null,"github":null,"blog":null,"score":0,"jobStatus":null,"scoreLevel":1,"followeeNum":1,"followNum":0,"followStatus":null,"vipExpireTime":"2025-04-01 23:41:46","vipNumber":"33488","userRole":"vip","scoreRank":null,"postAllThumbNum":null,"postAllViewNum":null,"needGuide":0,"syncPopupLeftCount":1,"paymentInfo":null},"tags":["面经","求职","伙伴匹配项目"],"fileList":null,"videoList":[],"atUserList":null,"pictureList":null,"hasThumb":false,"hasFavour":false,"needVip":null,"atUserVOList":null,"status":null,"relatedLink":null,"acceptAnswerId":null},{"id":"1834808386223161345","title":"【LeetCode】每日一题 2024_9_14 从字符串中移除星号（模拟）","description":"一起来刷每日一题","content":"# 前言\n每天和你一起刷 LeetCode 每日一题~\n# LeetCode 启动！\n<img src=\"https://pic.code-nav.cn/post_picture/1647972491353706498/n1sxaTSfgerPoyqB.webp\" alt=\"\" width=\"100%\" />\n今天的题目曾经的我做过了 . . . 又是复习的一天\n\n# 题目：[从字符串中移除星号](https://leetcode.cn/problems/removing-stars-from-a-string/description/?envType=daily-question&envId=2024-09-14)\n<img src=\"https://pic.code-nav.cn/post_picture/1647972491353706498/2nejIQB02Dlo3Mzw.webp\" alt=\"\" width=\"100%\" />\n\n## 代码与解题思路\n\n```go\nfunc removeStars(s string) string {\n    // 本题的核心：生成的输入保证总是可以执行题面中描述的操作。\n    // 这个提示的意思就是可以让我们直接对着字符串模拟即可，一定会有结果。\n    b := []rune{}\n    for _, v := range s {\n        if v == '*' { // 移除星号 左侧 最近的那个 非星号 字符，并移除该星号自身。\n           b = b[:len(b)-1]\n        } else { // 返回移除 所有 星号之后的字符串。\n            b = append(b, v)\n        }\n    }\n    return string(b)\n}\n```\n\n如注释所说，本道题的核心就在于理解题目中写着：“注意：”，后面的两行文字，然后直接根据题意进行模拟即可~\n\n# 每天进步一点点\n> 可以和我刷一辈子的每日一题吗？\n一题一题，积累起来就是一辈子。<img src=\"https://pic.code-nav.cn/post_picture/1647972491353706498/saFtRE5hDNnREkGm.webp\" alt=\"\" width=\"100%\" />\n","plainTextDescription":"一起来刷每日一题","category":"文章","cover":"https://pic.code-nav.cn/post_cover/1647972491353706498/vZWCH1bYuoDHL1Su.webp","thumbnailCover":"https://pic.code-nav.cn/post_cover/1647972491353706498/thumbnail/vZWCH1bYuoDHL1Su.png","language":null,"externalLink":null,"shortLink":null,"componentName":null,"viewNum":14,"thumbNum":3,"favourNum":0,"commentNum":0,"priority":0,"userId":"1647972491353706498","planetPostId":null,"relatedId":null,"showPost":0,"reviewStatus":1,"reviewMessage":null,"reviewerId":null,"reviewTime":"2024-09-14 12:16:23","editTime":"2024-09-14 12:16:23","createTime":"2024-09-14 12:16:23","updateTime":"2024-09-14 18:38:04","accessScope":0,"user":{"id":"1647972491353706498","planetCode":"20000","planetPostAuth":1,"userName":"戊子仲秋","userAvatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/3fDyEZXGRELEYPRrgo1Nv3ur9Nfu9KY8r4Na0I2fh5dueZCPVpLLlgAGBWgVx6HBxMpO1JUvtnpHD5bzbMaPFA/132","userThumbnailAvatar":null,"gender":null,"userProfile":"关山难越，谁悲失路之人？","interests":[],"place":null,"school":null,"direction":null,"graduationYear":null,"company":null,"job":null,"github":null,"blog":null,"score":0,"jobStatus":null,"scoreLevel":1,"followeeNum":21,"followNum":3,"followStatus":null,"vipExpireTime":"2025-05-12 00:25:26","vipNumber":"20000","userRole":"vip","scoreRank":null,"postAllThumbNum":null,"postAllViewNum":null,"needGuide":0,"syncPopupLeftCount":0,"paymentInfo":null},"tags":["Go","算法","学习打卡","交流"],"fileList":null,"videoList":[],"atUserList":null,"pictureList":null,"hasThumb":false,"hasFavour":false,"needVip":null,"atUserVOList":null,"status":null,"relatedLink":null,"acceptAnswerId":null},{"id":"1834802458723696641","title":"逮到一个爬我们网站的用户，手法拙劣到我想笑","description":"借这个事情，给大家分享一下如何快速定位爬虫和攻击者的方法。","content":"大家好，我是程序员鱼皮。昨天逮到一个爬取我们 [程序员面试刷题网站 - 面试鸭](https://www.mianshiya.com/) 的题目的用户，小伙子可能自以为很聪明，实际上手法非常拙劣！我一分钟不到就把他揪出来了。\n\n<p align=\"center\"><img src=\"https://pic.yupi.icu/1/image-20240730121945226-20240806114829247.png\" alt=\"\" width=\"414px\" /></p>\n\n下面聊一聊我是怎么做的，也借这个事情，给大家分享一下如何快速定位爬虫和攻击者的方法。\n\n\n\n## 如何纠出攻击者？\n\n### 发现猫腻\n\n生活中有人偷了你的东西，肯定要看监控。抓爬虫用户也是一样，先看监控。\n\n像我是怎么发现网站被爬了呢？首先我们系统内部有一套识别爬虫的策略，其次我们每天都会关注网站的流量情况，有些异常情况一眼便可看出。\n\n比如这次事件当天，我先通过系统云服务的监控看了下近 6 个小时向我们发送请求的客户端 IP，除去第一个是我们自己的 IP 外，其他几个 IP 的请求数都远超我们的业务平均值，显然这些 IP 不对劲！\n\n<img src=\"https://pic.yupi.icu/1/image-20240913101057942.png\" alt=\"\" width=\"100%\" />\n\n那这些 IP 都在请求什么资源呢？通过监控查看 URL 路径访问排行，发现获取题目信息的接口被调用了 10 万多次！\n\n<img src=\"https://pic.yupi.icu/1/image-20240913101745533.png\" alt=\"\" width=\"100%\" />\n\n然后我就根据这个路径进行筛选，查看访问它的客户端 IP 排行，除去第一个是我们自己的 IP 外，第二个 IP 的请求数显然有问题！\n\n<img src=\"https://pic.yupi.icu/1/image-20240913102027449.png\" alt=\"\" width=\"100%\" />\n\n然后根据这个 IP 进行筛选，分析他的请求情况：\n\n<img src=\"https://pic.yupi.icu/1/image-20240913102129531.png\" alt=\"\" width=\"100%\" />\n\n看到这个请求图，一眼就知道是爬虫了！我反正不信有正常用户半夜连续刷题 6 个多小时，你见过凌晨四点